using System.Collections.Immutable;
using System.IO.MemoryMappedFiles;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Robust.Roslyn.Shared;
using Robust.Roslyn.Shared.Helpers;
using static Robust.Shared.EntitySystemSubscriptionsGenerator.KnownTypes;

namespace Robust.Shared.EntitySystemSubscriptionsGenerator;

[Generator(LanguageNames.CSharp)]
public class SubGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var annotatedIEntitySystems = Aggregate(
                GetIEntityTypeCandidatesContainingAnnotatedMethods(context, AllSubscriptionMemberAttributeName),
                GetIEntityTypeCandidatesContainingAnnotatedMethods(context, NetworkSubscriptionMemberAttributeName),
                GetIEntityTypeCandidatesContainingAnnotatedMethods(context, LocalSubscriptionMemberAttributeName),
                GetIEntityTypeCandidatesContainingAnnotatedMethods(context, CallAfterSubscriptionsAttributeName)
            ) // Get all candidate types containing subscription annotated methods
            .SelectMany((array, _) => array.ToImmutableHashSet(PartialTypeInfo.WithoutLocationEqualityComparer)) // Dedupe
            .Combine(context.CompilationProvider)
            .Select((inputs, cancel) =>
                {
                    var (partialTypeInfo, compilation) = inputs;
                    if (compilation.GetTypeByMetadataName(partialTypeInfo.GetQualifiedName()) is not
                        { } entitySystemType)
                        return null;

                    var subs = ImmutableArray.CreateBuilder<SubscriptionInfo>();
                    var postSubs = ImmutableArray.CreateBuilder<PostSubscriptionInfo>();
                    foreach (var method in entitySystemType.GetMembers().OfType<IMethodSymbol>())
                    {
                        cancel.ThrowIfCancellationRequested();

                        if (TryParseSubscriptions(method) is { } sub)
                        {
                            subs.Add(sub);
                        }

                        if (TryParsePostSubscription(method) is { } postSub)
                        {
                            postSubs.Add(postSub);
                        }
                    }

                    if (subs.Count == 0 && postSubs.Count == 0)
                        return null;

                    return new IEntitySystemInfo(
                        partialTypeInfo,
                        subs.ToImmutable(),
                        postSubs.ToImmutable()
                    );
                }
            );

        context.RegisterImplementationSourceOutput(
            annotatedIEntitySystems.Where(it => it is not null),
            (productionContext, info) =>
            {
                var (partialTypeInfo, subscriptions, postSubscriptions) = info!;

                var subscriptionsSyntax = new StringBuilder();
                foreach (var method in subscriptions)
                {
                    productionContext.CancellationToken.ThrowIfCancellationRequested();
                    var subscriptionMethod = method.Type.ToSubscriptionMethod();
                    var typeArgs = string.Join(", ", method.TypeArgs);
                    subscriptionsSyntax.AppendLine($"        {subscriptionMethod}<{typeArgs}>({method.MethodName});");
                }

                var callAfterSyntax = new StringBuilder();
                foreach (var method in postSubscriptions)
                {
                    productionContext.CancellationToken.ThrowIfCancellationRequested();
                    callAfterSyntax.AppendLine($"        {method.MethodName}();");
                }

                var builder = new StringBuilder(@"
// <auto-generated />

using Robust.Shared.GameObjects;

");
                partialTypeInfo.WriteHeader(builder);
                builder.AppendLine($@"
{{
    [MustCallBase]
    public override void Initialize()
    {{
        base.Initialize();

{subscriptionsSyntax}
{callAfterSyntax}
    }}
}}
");
                partialTypeInfo.WriteFooter(builder);

                productionContext.AddSource(partialTypeInfo.GetGeneratedFileName(), builder.ToString());
            }
        );
    }

    private static IncrementalValuesProvider<PartialTypeInfo>
        GetIEntityTypeCandidatesContainingAnnotatedMethods(
            IncrementalGeneratorInitializationContext context,
            string attributeName
        )
    {
        return context.SyntaxProvider.ForAttributeWithMetadataName(
                attributeName,
                (node, _) => node is MethodDeclarationSyntax,
                (ctx, _) =>
                {
                    if (ctx.TargetSymbol is not IMethodSymbol symbol ||
                        ctx.TargetNode is not MethodDeclarationSyntax { Parent: TypeDeclarationSyntax parentSyntax })
                        return null;

                    return PartialTypeInfo.FromSymbol(symbol.ContainingType, parentSyntax);
                })
            .Where(it => it is not null)
            .Select((it, _) => it ?? throw new("Unreachable"));
    }

    private static SubscriptionInfo? TryParseSubscriptions(IMethodSymbol method)
    {
        return TryParseSubscription(
            method,
            AllSubscriptionMemberAttributeName,
            m => TryParseEntityEventHandler(m) ?? TryParseEntitySessionEventHandler(m)
        ) ?? TryParseSubscription(
            method,
            NetworkSubscriptionMemberAttributeName,
            m => TryParseEntityEventHandler(m) ?? TryParseEntitySessionEventHandler(m)
        ) ?? TryParseSubscription(
            method,
            LocalSubscriptionMemberAttributeName,
            m => TryParseEntityEventHandler(m) ??
                 TryParseEntitySessionEventHandler(m) ??
                 TryParseComponentEventHandler(m) ??
                 TryParseEntityEventRefHandler(m)
        );
    }

    public static ImmutableArray<string>? TryParseEntityEventHandler(IMethodSymbol method)
    {
        if (method.Parameters.Length != 1 ||
            method.Parameters[0].Type is not INamedTypeSymbol eventType)
            return null;

        return [eventType.ToString()];
    }

    public static ImmutableArray<string>? TryParseEntitySessionEventHandler(IMethodSymbol method)
    {
        if (method.Parameters.Length != 2 ||
            method.Parameters[0].Type is not INamedTypeSymbol eventType ||
            !TypeSymbolHelper.ShittyTypeMatch(
                method.Parameters[1].Type,
                EntitySessionEventArgsTypeName
            ))
            return null;

        return [eventType.ToString()];
    }

    public static ImmutableArray<string>? TryParseEntityEventRefHandler(IMethodSymbol method)
    {
        if (method.Parameters.Length != 2 ||
            method.Parameters[0].Type is not INamedTypeSymbol entityType ||
            method.Parameters[1].Type is not INamedTypeSymbol eventType)
            return null;

        if (entityType.OriginalDefinition.ToDisplayString() != EntityTypeName ||
            entityType.TypeArguments is not [INamedTypeSymbol componentType] ||
            !TypeSymbolHelper.ImplementsInterface(componentType, IComponentTypeName))
            return null;

        return [componentType.ToString(), eventType.ToString()];
    }

    public static ImmutableArray<string>? TryParseComponentEventHandler(IMethodSymbol method)
    {
        if (method.Parameters.Length != 3 ||
            method.Parameters[0].Type is not INamedTypeSymbol entityUidType ||
            method.Parameters[1].Type is not INamedTypeSymbol componentType ||
            method.Parameters[2].Type is not INamedTypeSymbol eventType ||
            !TypeSymbolHelper.ShittyTypeMatch(entityUidType, EntityUidTypeName) ||
            !TypeSymbolHelper.ImplementsInterface(componentType, IComponentTypeName))
            return null;

        return [componentType.ToString(), eventType.ToString()];
    }

    private static SubscriptionInfo? TryParseSubscription(
        IMethodSymbol method,
        string annotationName,
        Func<IMethodSymbol, ImmutableArray<string>?> parseFunc
    )
    {
        if (annotationName.ToSubscriptionType() is not { } subType ||
            !AttributeHelper.HasAttribute(method, annotationName, out _) ||
            parseFunc(method) is not { } parameters)
            return null;

        return new SubscriptionInfo(method.Name, subType, parameters);
    }

    public static bool TakesNoParameters(IMethodSymbol method)
    {
        return method.Parameters.Length == 0 && method.TypeArguments.Length == 0;
    }

    private static PostSubscriptionInfo? TryParsePostSubscription(IMethodSymbol method)
    {
        if (!AttributeHelper.HasAttribute(method, CallAfterSubscriptionsAttributeName, out _) ||
            !TakesNoParameters(method))
            return null;

        return new PostSubscriptionInfo(method.Name);
    }

    private static IncrementalValueProvider<ImmutableArray<T>> Aggregate<T>(
        IncrementalValuesProvider<T> first,
        params IncrementalValuesProvider<T>[] more
    )
    {
        return more.Aggregate(
            first.Collect(),
            (acc, valuesProvider) =>
                acc.Combine(valuesProvider.Collect())
                    .Select((values, _) => values.Left.AddRange(values.Right))
        );
    }

    private sealed record IEntitySystemInfo(
        PartialTypeInfo Type,
        EquatableArray<SubscriptionInfo> Subscriptions,
        EquatableArray<PostSubscriptionInfo> PostSubscriptions
    );

    private sealed record SubscriptionInfo(string MethodName, SubscriptionType Type, EquatableArray<string> TypeArgs);

    private sealed record PostSubscriptionInfo(string MethodName);
}

[Generator(LanguageNames.CSharp)]
public class SubGenErrors : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        VerifyAnnotatedMethodIsInPartialIEntitySystem(context, AllSubscriptionMemberAttributeName);
        VerifyAnnotatedMethodIsInPartialIEntitySystem(context, NetworkSubscriptionMemberAttributeName);
        VerifyAnnotatedMethodIsInPartialIEntitySystem(context, LocalSubscriptionMemberAttributeName);
        VerifyAnnotatedMethodIsInPartialIEntitySystem(context, CallAfterSubscriptionsAttributeName);


        VerifyAnnotatedMethodHasCorrectSignature(
            context,
            AllSubscriptionMemberAttributeName,
            m => (SubGen.TryParseEntityEventHandler(m) ?? SubGen.TryParseEntitySessionEventHandler(m)) is not null,
            NonComponentSubscriptionHandlerTypes
        );
        VerifyAnnotatedMethodHasCorrectSignature(
            context,
            NetworkSubscriptionMemberAttributeName,
            m => (SubGen.TryParseEntityEventHandler(m) ?? SubGen.TryParseEntitySessionEventHandler(m)) is not null,
            NonComponentSubscriptionHandlerTypes
        );
        VerifyAnnotatedMethodHasCorrectSignature(
            context,
            LocalSubscriptionMemberAttributeName,
            m => (
                SubGen.TryParseEntityEventHandler(m) ??
                SubGen.TryParseEntitySessionEventHandler(m) ??
                SubGen.TryParseComponentEventHandler(m) ??
                SubGen.TryParseEntityEventRefHandler(m)
            ) is not null,
            string.Join(", ", NonComponentSubscriptionHandlerTypes, ComponentSubscriptionHandlerTypes)
        );
        VerifyAnnotatedMethodHasCorrectSignature(
            context,
            CallAfterSubscriptionsAttributeName,
            SubGen.TakesNoParameters,
            CallAfterSubscriptionsHandlerTypes
        );


        // TODO Complain when:
        //  - Annotations are in a class which already has an `Initialize` (Maybe? Maybe just let the compiler choke on this one)
    }

    private static void RegisterDiagnosticReporting(
        IncrementalGeneratorInitializationContext context,
        IncrementalValuesProvider<Diagnostic?> diagnostics
    )
    {
        context.RegisterSourceOutput(
            diagnostics.Where(it => it is not null),
            (productionContext, diagnostic) => productionContext.ReportDiagnostic(diagnostic!)
        );
    }

    private static void VerifyAnnotatedMethodIsInPartialIEntitySystem(
        IncrementalGeneratorInitializationContext context,
        string annotationName
    )
    {
        var diagnostics = context.SyntaxProvider.ForAttributeWithMetadataName(
            annotationName,
            (node, _) => node is MethodDeclarationSyntax,
            (syntaxContext, _) =>
            {
                var diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();

                if (syntaxContext.TargetSymbol.ContainingType is not { } containingSymbol ||
                    !TypeSymbolHelper.ImplementsInterface(containingSymbol, IEntitySystemTypeName))
                {
                    diagnostics.Add(Diagnostic.Create(
                        Diagnostics.NotIEntitySystem,
                        syntaxContext.TargetSymbol.Locations[0],
                        syntaxContext.TargetSymbol.ContainingType?.Name ?? "<unknown>"
                    ));
                }

                if (syntaxContext.TargetNode.Parent is not TypeDeclarationSyntax containingSyntax ||
                    !containingSyntax.Modifiers.Any(x => x.IsKind(SyntaxKind.PartialKeyword)))
                {
                    diagnostics.Add(Diagnostic.Create(
                        Diagnostics.NotPartial,
                        syntaxContext.TargetSymbol.Locations[0]
                    ));
                }

                return diagnostics.ToImmutable().AsEquatableArray();
            }
        );

        RegisterDiagnosticReporting(
            context,
            diagnostics.SelectMany((array, _) => array as IEnumerable<Diagnostic?>)
        );
    }

    private static void VerifyAnnotatedMethodHasCorrectSignature(
        IncrementalGeneratorInitializationContext context,
        string annotationName,
        Func<IMethodSymbol, bool> hasCorrectParameters,
        string acceptableHandlerTypes
    )
    {
        var diagnostics = context.SyntaxProvider.ForAttributeWithMetadataName(
            annotationName,
            (node, _) => node is MethodDeclarationSyntax,
            (syntaxContext, _) =>
            {
                if (syntaxContext.TargetSymbol is not IMethodSymbol method ||
                    !method.ReturnsVoid ||
                    !hasCorrectParameters(method))
                {
                    return Diagnostic.Create(
                        Diagnostics.BadMethodSignature,
                        syntaxContext.TargetSymbol.Locations[0],
                        annotationName,
                        acceptableHandlerTypes
                    );
                }

                return null;
            }
        );

        RegisterDiagnosticReporting(context, diagnostics);
    }
}
